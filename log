changes made:
console.c:
	read_proc. EOL and CR constants inside the switch case
	son cambios necesarios para poder compilar con -O0 (sin optimizacion).

las funcionas __inline se han sustituido por la misma razon de arriba

La opcion -gdb tcp::1234 de el programa qemu te crea un servidor local en el puerto localhost:1234
para poder hacer debugeo remoto de lo que se esta ejecutando y la opcion -S va hacer que una vez
empieze qemu a ejecutar se pare, esto nos permite enlazar a mano el gdb que esta en la carpeta
compiler/bin/arm-none-eabi-gdb a qemu.

una vez teneis qemu ejecutando y parado, lo que teneis que hacer es llamar al programa 
del gdb y utilizar el comando "file build/myos.elf" ese comando lo que hara sera parsear
el archivo compilado de nuestro SO. Tened en cuenta que para que pueda parsearlo correctamente, 
es neesario utilizar el parametro -g para el compilador, eso lo que hara sera no borrar tablas de
simbolos e identificadores necesarios para que gdb entienda el programa.

cuando esteis dentro de gdb y hayais cargado el archivo buidl/myos.elf lo siguiente que teneis
que hacer es enlazarlo a qemu con el comando "target remote localhost:1234" y listo, ya podeis
empezar a debuggear

Algunos comandos utiles:
b <nombre de funciona> ---> creara un breakpoint en la funcion que le pongais
nexti ---> ejecutara una linea de codigo sin entrar en las posibles llamas a otras rutinas
next ---> ejecutara todas las lineas de codigo necesarias hasta que algo lo pare (aka un breakpoint)
tambien hace algo mas pero ni idea
step ---> lo mismo que next pero entrando en las llamadas a subrutinas
bt o backtrace ---> te permite ver en flujo de llamadas a funciones hecho hasta la linea en la que 
este pc
print <variable> ---> te permite ver el contenido de la variable. la <variable> puede ser un registro
(teneis que incluirle $ delante) y una direccion de memoria. se puede ver el contenido de un puntero
poniendo * y la direccion de memoria que contiene <variable> con &

watch <variable> ---> es un tipo de breakpoint especial, parara la ejecucion del programa cuando el
valor de <variable> cambie

layout asm ---> te permite ver el codigo ensamblador que se esta ejecutando, en vez de asm se puede 
usar src para el codigo c, y regs para ver los registros durante la ejecucion. para salir dadle a
ctrl + x + a

disassemble <function> te muestra en codigo ensamblador de la funcion, no se puede usar despues de eejecutar
layout

info break ---> te da una lista de todos los breakpoints, info es un comando general, se pueden hacer mas cosas

x ---> te muestra el valor de una direcion de memoria buscad en que se diferencia del print

y de momento ya no se mucho mas, ala a debuggear cologos